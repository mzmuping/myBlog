(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{456:function(e,a,s){"use strict";s.r(a);var c=s(45),t=Object(c.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h3",{attrs:{id:"概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),s("p",[e._v("首先，我们要明确，为什么涉及到高并发后，我们要用到数据缓存。这是因为当一个业务接口被用户调用后，系统首先会进入对应业务方法中进行逻辑运算，之后会根据逻辑运算结果，访问对应的数据SQL语句，对数据进行调用或者修改。这一系列的业务流程走完是需要时间的。但在面对高并发的环境下，哪怕是1毫秒的反映时间，都是至关重要。如何提高业务接口的交互效率，这里就可以使用数据缓存（对于公共数据来说，在用户第一次访问的时候根据访问KEY将返回值缓存起来，当用户下次再次访问的时候，直接从缓存当中调用对应数据，从来提高接口相应速度")]),e._v(" "),s("p",[e._v("我遇到的缓存主要有redis和Cache两种。两个大致都是将数据放到缓存中以便用户下次调用时直接返回。但是两者的差异也是蛮大的，因此在不同的项目当中也会选择不同的方式。")]),e._v(" "),s("h3",{attrs:{id:"先看看redis和cache的区别吧"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#先看看redis和cache的区别吧"}},[e._v("#")]),e._v(" 先看看redis和Cache的区别吧")]),e._v(" "),s("ul",[s("li",[e._v("Redis和cache都是将数据存放在内存中，都是内存数据库。不过cache还可用于缓存其他东西，例如图片、视频等等")]),e._v(" "),s("li",[e._v("Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。")]),e._v(" "),s("li",[e._v("虚拟内存-Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘")]),e._v(" "),s("li",[e._v("过期策略–cache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如业务配置进行设定")]),e._v(" "),s("li",[e._v("分布式–设定cache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从")]),e._v(" "),s("li",[e._v("存储数据安全–cache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）")]),e._v(" "),s("li",[e._v("灾难恢复–cache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复")]),e._v(" "),s("li",[e._v("Redis支持数据的备份，即master-slave模式的数据备份。")])]),e._v(" "),s("h3",{attrs:{id:"关于redis和memcache的不同"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于redis和memcache的不同"}},[e._v("#")]),e._v(" 关于redis和memcache的不同")]),e._v(" "),s("ul",[s("li",[e._v("存储方式\n"),s("ul",[s("li",[e._v("cache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小")]),e._v(" "),s("li",[e._v("redis有部份存在硬盘上，这样能保证数据的持久性，支持数据的持久化（笔者注：有快照和AOF日志两种持久化方式，在实际应用的时候，要特别注意配置文件快照参数，要不就很有可能服务器频繁满载做dump）")])])]),e._v(" "),s("li",[e._v("数据支持类型\n"),s("ul",[s("li",[e._v("redis在数据支持上要比cache多的多。")])])]),e._v(" "),s("li",[e._v("使用底层模型不同\n"),s("ul",[s("li",[e._v("新版本的redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求")])])])]),e._v(" "),s("h3",{attrs:{id:"cache-管理包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cache-管理包"}},[e._v("#")]),e._v(" cache 管理包")]),e._v(" "),s("ul",[s("li",[e._v("cache-manager")]),e._v(" "),s("li",[e._v("memached")])]),e._v(" "),s("h3",{attrs:{id:"选择"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#选择"}},[e._v("#")]),e._v(" 选择")]),e._v(" "),s("p",[e._v("有持久化需求或者对数据结构和处理有高级要求的应用，选择redis。其他简单的key/value存储，选择cache")]),e._v(" "),s("h3",{attrs:{id:"cached介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cached介绍"}},[e._v("#")]),e._v(" cached介绍")])])}),[],!1,null,null,null);a.default=t.exports}}]);