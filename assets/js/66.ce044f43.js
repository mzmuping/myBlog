(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{483:function(t,v,a){"use strict";a.r(v);var _=a(45),e=Object(_.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"虚拟dom是什么-有缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom是什么-有缺点"}},[t._v("#")]),t._v(" 虚拟dom是什么，有缺点")]),t._v(" "),a("p",[t._v("虚拟dom其实一个js树形tree对象,简化了真实渲染树\n特点：\n1. 比较属性，减少dom操作，减少重绘和回流\n2. 有跨端能力，使用不同端编译器就可以实现跨端\n缺点：\n1、对象是存储在内存中，耗费一定资源，加上而外算法\n2、超出dom列表，首次渲染还是比较慢")]),t._v(" "),a("h2",{attrs:{id:"diff算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff算法"}},[t._v("#")]),t._v(" diff算法")]),t._v(" "),a("ol",[a("li",[t._v("vue使用patching算法，snabbdom修改改进，由虚拟dom转换真实dom")]),t._v(" "),a("li",[t._v("vue中每个组件都对应一个watcher监听响应式数据，再通过patching算法找到发生变化地方，并修改更新")]),t._v(" "),a("li",[t._v("vue中diff执行是在于响应式数据发生更变，触发实例执行更新函数，更新函数会重新调用render方法，render函数返回新的虚拟dom,然后就执行patch函数进行对比，然后改变新值")])]),t._v(" "),a("h2",{attrs:{id:"patch过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#patch过程"}},[t._v("#")]),t._v(" patch过程")]),t._v(" "),a("p",[t._v("执行一个递归过程，遵循深度优先，同层比较的策略")]),t._v(" "),a("ol",[a("li",[t._v("比较两个节点类型是否想同，不同则删除重新创建")]),t._v(" "),a("li",[t._v("如果是文本型的，就删除旧的，创建新的")]),t._v(" "),a("li",[t._v("如果有子节点，有判断更更新\n"),a("ol",[a("li",[t._v("新子节点是文本，旧子节点是数组，则创建新的文本")]),t._v(" "),a("li",[t._v("新子节点是文本，旧子节点是文本，则更新文本")]),t._v(" "),a("li",[t._v("新子节点是数组，旧子节点是文本，则创建新子节点数组元素")]),t._v(" "),a("li",[t._v("新子节点是数组，旧子节点是数组，递归patch函数，通过双端比较")])])]),t._v(" "),a("li",[t._v("vue3.优化策略，编译优化添加patchFlags,\n"),a("ul",[a("li",[t._v("patchFlags 静态标记，")]),t._v(" "),a("li",[t._v("静态提升，")]),t._v(" "),a("li",[t._v("基于最长递增子序列进行移动/添加/删除")])])])])])}),[],!1,null,null,null);v.default=e.exports}}]);